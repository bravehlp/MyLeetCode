package $_477_hamming_distance_total;
/**
 * ━━━━━━神兽出没━━━━━━
 * 　　 ┏┓     ┏┓
 * 　　┏┛┻━━━━━┛┻┓
 * 　　┃　　　　　 ┃
 * 　　┃　　━　　　┃
 * 　　┃　┳┛　┗┳  ┃
 * 　　┃　　　　　 ┃
 * 　　┃　　┻　　　┃
 * 　　┃　　　　　 ┃
 * 　　┗━┓　　　┏━┛　Code is far away from bug with the animal protecting
 * 　　　 ┃　　　┃    神兽保佑,代码无bug
 * 　　　　┃　　　┃
 * 　　　　┃　　　┗━━━┓
 * 　　　　┃　　　　　　┣┓
 * 　　　　┃　　　　　　┏┛
 * 　　　　┗┓┓┏━┳┓┏┛
 * 　　　　 ┃┫┫ ┃┫┫
 * 　　　　 ┗┻┛ ┗┻┛
 * <p>
 * ━━━━━━感觉萌萌哒━━━━━━
 */

import java.util.*;

/**
 * @version V1.0
 * @Title: Solution.java
 * @Package $_461_hamming_distance
 * @Description: 计算一个整数数组中，任意两个元素组合的汉明距离总和
 * 提示：
 * 1 <= nums.length <= 10^5
 * 0 <= nums[i] <= 10^9
 * @date 2021-05-28 19:18
 */
public class Solution {

    /**
     * 方案一：
     * 任意两个数间的汉明距离可以得出；若要计算一个数组中任意两个数字间的汉明距离，把所有组合找出来，然后把所有汉明距离相加即可。
     * 问题就变为了：把int数组中所有两两组合找出来，即从第一个元素开始，与它后面的每一个元素都组合一次，直到最后一个元素。
     * <p>
     * 编程方案：
     * 两层for嵌套，挨个计算，外层循环为int数组从0开始，内层循环为'去掉外层已遍历过的元素'后的列表；
     * 考虑到数组不可直接删除元素，那就用List进行操作，即内层循环的元素从一个新的List中取。开始内层循环前把外层已遍历过的元素删掉；
     * 在内层循环里，迭代进行汉明距离统计即可。
     * <p>
     * 方案结果：
     * 计算正确，但未通过官方测试，理由是速度太慢。
     * <p>
     * 方案问题：
     * 1、多增加了一个for循环
     * 2、要对List进行额外操作
     * 3、没有利用题目给出的提示
     *
     * @param nums
     * @return
     */
    @Deprecated
    public int totalHammingDistance1(int[] nums) {

        int totalHd = 0;

        List<Integer> innerList = new ArrayList<>();

        // 把数组转为List，方便内层循环remove元素
        for (int num : nums) {
            innerList.add(new Integer(num));
        }

        for (int outterNum : nums) {
            // 外层循环：迭代每一个元素

            // 排除掉已用过的元素
            innerList.remove(new Integer(outterNum));

            for (int i = 0; i < innerList.size(); i++) {
                // 内存循环：迭代去除外层元素后的每一个元素

                int innerNum = (int) innerList.get(i);

                // JDK内置方法，可返回一个整形的二进制中包含1的数量
                int hd = Integer.bitCount(outterNum ^ innerNum);

                // 累加汉明距离：前面所有组合的汉明距离 + 本次汉明距离
                totalHd = totalHd + hd;
            }

        }

        return totalHd;
    }

    /**
     * 方案二：
     * 方案一的最大问题在于内层循环的元素来源是List，造成徒增一个循环和多了remove操作。
     * 能不能不借助List来进行操作呢？
     * 内层迭代的本质是，只迭代外层元素位置之后的所有元素，那就在内层只访问外层index之后的元素就可以了。
     * <p>
     * <p>
     * 编程方案：
     * 两层for嵌套，挨个计算，外层循环为int数组从0开始，内层循环为'外层遍历的元素'位置后的所有元素；
     * 在内层循环里，迭代进行汉明距离统计即可。
     * <p>
     * 方案结果：
     * 计算正确，通过了官方测试，但速度依然太慢。
     * <p>
     * 方案问题：
     * 1、依然是从宏观角度思考解法，即考虑数组元素的直接操作；没有从微观层面考虑，即没有从'位'操作的角度切入。
     * 2、也没有利用上题目给定的提示条件。
     */
    public int totalHammingDistance2(int[] nums) {

        // 所有元素的总汉明距离
        int totalHd = 0;

        for (int i = 0; i < nums.length; i++) {
            // 外层循环：迭代每一个元素

            for (int j = i + 1; j < nums.length; j++) {
                // 内存循环：迭代外层元素后的每一个元素

                // JDK内置方法，可返回一个整形的二进制中包含1的数量
                int hd = Integer.bitCount(nums[i] ^ nums[j]);

                // 累加汉明距离：前面所有组合的汉明距离 + 本次汉明距离
                totalHd = totalHd + hd;
            }
        }

        return totalHd;

    }


    /**
     * 方案三：
     * <p>
     * 先前两个方案的问题都是从宏观数字方面考虑问题，没有从'位'操作的角度思考。因为汉明距离从概念和计算里就透露出两个重要内容：二进制、位，那就试着从二进制和'位'的方向入手思考。
     * <p>
     * 思考一：把数组内所有整形数字抽象思考为二进制数组，即数组内所有元素都是'二进制形式'的数。
     * 思考二：汉明距离计算：任意两个数字做'异或'运算，其结果的二进制形式中数字'1'的个数。
     * 这里面有两个重要概念：异或运算、1的个数。
     * 异或运算：二元运算时，两个元素不一样，则返回1。也就是只有当一个元素是'1'，一个元素是'0'时，其结果才是'1'。把两个数字二进制的对应位置'1'和'0'的组合找出来即可。
     * 1的个数：异或结果中1的数量。
     * 两个概念综合起来就是，1 = 1 ^ 0，即 '1 的个数'就是 '1 ^ 0 的个数'，也就是把所有'1和1'、'0和0'的组合都舍弃，只把'1和0 的组合'都找出来即可。
     * <p>
     * 综合以上思考，问题就变为了寻找数组中任意两个二进制组合中，相同'位'上有多少 '1 和 0 的组合'。
     * 这里就变成了一个数学问题，即 '1和0 的组合' = '1的个数' 与 '0的个数' 之间有多少种组合形式，也就是 '1的个数' 乘以 '0的个数'。
     * 举例说明：
     * int[] a = {1, 1, 1, 1};
     * int[] b = {0, 0, 0};
     * <p>
     * 1和0的组合方案就是，a中的每一个元素依次与b中的元素组合一遍。
     * a中的第一个元素与b中的每一个元素都组合一遍就是3个组合，a中的第二个元素与b中的每一个元素都组合一遍就是3个组合，a中后面的元素同理也都是3个组合。
     * 1*3 + 1*3 + 1*3 + 1*3 = (1+1+1+1)*3 = 4*3 = a的元素数 * b的元素数。
     * <p>
     * 因为二进制中只有1和0，所以本数组中所有元素的二进制在相同'位'上只有1或0。假设数组长度为 n ，所有元素的 某'位' 上有 x 个1，那剩下的元素在此'位'上就都是0，即有 'n - x' 个0，那1和0的所有组合就是 'x * (n-x)'。
     * 'x * (n-x)' 就是 1 和 0 做异或运算的数量，也就是结果中1的个数。这个公式中，n是已知的，只有 x（1的个数）需要统计出来，那就想办法去统计每一个元素在当前'位'上有多少个1即可。
     * <p>
     * 限定'位'的序号，统计数组中每个元素在此'位'上'1'的个数；此'位'统计完后，再统计下一'位'上每个元素中'1'的个数，这很明显也是两层循环的嵌套，内层为数组的遍历，外层为'位'的索引列表。
     * 但每个数字长度有多少'位'是未知的，也就无法限定外层循环。此时，观察给出的提示条件有一个 '0 <= nums[i] <= 10^9'，此处限定了每个元素的大小，二进制看法就是元素的'位'数多少。
     * 此处假定每个元素都是最大的即可，所以得出 10^9 的二进制即可，通过log计算得出 2^29 < 10^9 < 2^30，此处采用最大值，即认为数组中最大值为 2^30，也就是说元素的二进制位最多有30个。
     * <p>
     * 编程方案：
     * 两层for嵌套，外层遍历'位'的序号，即 [0, 30)；
     * 在内层循环里，遍历每个元素，统计它们在此'位'上有多少个'1'；
     * 内层循环结束后，即得到了 'x * (n-x)' 中 x 的值，进行一次 'x * (n-x)' 运算，即可得出所有元素两两组合后，在此'位'上1的个数
     * <p>
     * <p>
     * 方案结果：
     * 计算正确，通过了官方测试。
     * <p>
     * 方案问题：
     * 1、如果数组中元素值都较小，那二进制形式下的位数就不会太大，那外层依然循环30次即为浪费
     *
     * @param nums
     * @return
     */
    public int totalHammingDistance(int[] nums) {

        // 总的汉明距离
        int totalHd = 0;

        for (int i = 0; i < 30; i++) {
            // 外层遍历'位'序号

            // 所有元素在此'位'上1的个数
            int oneCount = 0;

            for (int num : nums) {
                // 内层遍历所有元素

                /*
                 * 获取指定'位'的数据，由于直接获取比较麻烦，因此取巧为使此数字每次都向右移动
                 * 使得此'位'移动到最后一位，再与1做'与'运算，进而判断此'位'是否是1
                 */

                int postionLast = num >> i;

                // 此处要注意先进行'位'与运算，用括号做限定
                oneCount = oneCount + (postionLast & 1);

            }

            // 总距离 = 访问过的'位'的汉明距离，再加上 '1的个数 * (数据长度 — 1的个数)'
            totalHd = totalHd + oneCount * (nums.length - oneCount);

        }

        return totalHd;

    }


}
